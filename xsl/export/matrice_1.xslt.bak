<?xml version="1.0" encoding="UTF-8"?>
<!--Template to transform ARCHI 2.2.0. XML model to the table form in CSV with semicolon -->
<!-- The intent is to describe one hierarchy (taxonomy) of artefacts on the left side and the linked with another artifact (also with possible hierarchy) on the right side. For example: Let imagine the hierarchy of business "functions" (from domain, subdomain, areas, ..., functions) and you are interested in relationships between these functions and application services or business processes and so on with respect on depicting their hierarchies. Hierarchies are defined by directory/folder structure.  -->
<!--Expected output is CSV : (example):-->
<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:archimate="http://www.bolton.ac.uk/archimate">
	<xsl:output method="text" version="1.0" encoding="UTF-8" indent="yes"/>
	<!--Top level hierarchy directory/folder-->
	<!--
<xsl:param name="leftSideHierarchy" select="/archimate:model/folder[@type='business']/folder[@name='Functions']"/>
-->
	<xsl:param name="leftSideHierarchy" select="/archimate:model/folder[@type='business']"/>
	<xsl:param name="rightSideHierarchy" select="/archimate:model/folder[@type='application']/folder"/>
	<xsl:template match="/" priority="0.1">
		<xsl:message>nonProduction template&#xA;</xsl:message>
		<xsl:variable name="maxNest">
			<xsl:call-template name="ComputeNesting">
				<xsl:with-param name="selectFrom" select="$leftSideHierarchy"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:apply-templates select="$leftSideHierarchy/folder">
			<xsl:with-param name="_indent" select="0"/>
			<xsl:with-param name="_maxNest" select="$maxNest"/>
		</xsl:apply-templates>
	</xsl:template>
	<xsl:template name="ComputeNesting">
		<xsl:param name="selectFrom"/>
		<xsl:for-each-group group-by="." select="$selectFrom//folder">
			<xsl:sort select="count(/ancestor-or-self::*)" order="descending"/>
			<nesting word="{current-grouping-key()}" nesting="{count(/ancestor-or-self::node())}"/>
		</xsl:for-each-group>
	</xsl:template>
	<xsl:template match="/" priority="0.01">
		<xsl:message>nonnonProduction template&#xA;</xsl:message>
		<xsl:apply-templates select="$leftSideHierarchy//folder"/>
	</xsl:template>

  <xsl:template match="/" priority="10">
	<xsl:message>Production template&#xA;</xsl:message>
	<xsl:apply-templates select="$leftSideHierarchy//folder"/>
</xsl:template>

  <xsl:template match="folder">
     <xsl:for-each select="ancestor::*">
     <!-- Walking through ancestors named 'component'.
          By default, for-each traverses the nodes in document order -->
       <xsl:if test="position() &gt; 1">
         <!-- add a '/' delimiter in front of all steps but the 
  first one -->
         <xsl:text>/</xsl:text>
       </xsl:if>
       <xsl:value-of select="@name"/>
     </xsl:for-each>
  </xsl:template>

<!--
	<xsl:template match="folder">
		<xsl:text>"</xsl:text>
		<xsl:value-of select="$_indent"/>
		<xsl:text>";</xsl:text>
		<xsl:text>"</xsl:text>
		<xsl:value-of select="count(ancestor-or-self::*)"/>
		<xsl:text>";</xsl:text>
		<xsl:text>"</xsl:text>
		<xsl:value-of select="@name"/>
		<xsl:text>"&#xA;</xsl:text>
		<xsl:apply-templates select="child::folder">
			<xsl:with-param name="_indent" select="$_indent+1"/>
		</xsl:apply-templates>
	</xsl:template>
-->
</xsl:stylesheet>
